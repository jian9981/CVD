
library(survey)
library(questionr)
#get KM estimate given weight. Jian modified Chong's code to get this
wtkm=function(dat, evtvar="death" , dayvar="death.days",treatvar="trt", wt= "weight" ){
  fm=as.formula(paste("Surv(", dayvar, ",", evtvar, ")~",treatvar ) );fm
  des=svydesign(ids=~1, weights=~eval(parse(text=wt)), data=dat) 
  s1<-svykm(fm, design=des)
  (trt0=s1[[1]])
  Time=trt0$time
  cif=1-trt0$surv
  ev0=data.frame(Time, cif) %>% mutate(group=names(s1)[1])
  trt1=s1[[2]]
  Time=trt1$time
  cif=1-trt1$surv
  ev1=data.frame(Time, cif) %>% mutate(group=names(s1)[2])
  cif.death.raw=rbind(ev0,ev1)
  names(cif.death.raw)=c(dayvar, "cif",treatvar )
  return(cif.death.raw)}



#Crystal created this function by modifying code from Chong
#Requirements for the input data dat: 1) the treatment variable should be named as trt and encoded as 0=control 1=test
#2)the event status should be encoded as 0=censor, 1=event of interest, 2=competing event
getcif_faster = function(dat, tx, evtvar, dayvar, weightvar=NULL) {
  dat = dat[!is.na(dat[, dayvar]) & dat[, dayvar]>0,]
  tmpdat = dat[dat$trt==tx,]
  
  if(is.null(weightvar)){wt=rep(1,nrow(tmpdat))}else{wt=tmpdat[,weightvar]}
  
  #tmpdat%>% select(Status, ftime) %>% arrange(ftime) %>% filter(Status>0) %>%  head
  
  tm1 = sort(unique(tmpdat[,dayvar][tmpdat[,evtvar]==1]));tm1
  ntm1 = length(tm1) 
  tm12 = sort(unique(tmpdat[,dayvar][tmpdat[, evtvar]!=0]))
  ntm12 = length(tm12)
  
  # KM estimator for the event of interest 
  atrisk1 = rep(0,ntm1)
  nj1 = rep(0,ntm1)
  haz1 = rep(0,ntm1)
  
  tmpdat1 <- tmpdat %>%
    mutate(wt = wt)
  
  tmpdat1_event <- tmpdat1 %>%
    filter(!!as.name(evtvar)==1)
  
  nj1 <- data.frame(wtd.table(tmpdat1_event[,dayvar], weights=tmpdat1_event$wt))
  names(nj1) <- c("time", "w.sum.event")
  
  atrisk_all <- data.frame(wtd.table(tmpdat1[,dayvar], weights=tmpdat1$wt))
  names(atrisk_all) <- c("time", "w.sum")
  
  atrisk1 <- atrisk_all %>%
    arrange(desc(time))%>%
    mutate(w.cum.sum = cumsum(w.sum))%>%
    filter(time %in% nj1$time)%>%
    arrange(time)
  
  # check the times in two data sets match
  if(setequal(nj1$time, atrisk1$time)!=TRUE){
    stop("Time points do not match")
  }
  haz1 <- nj1$w.sum.event/atrisk1$w.cum.sum
  
  # KM estimator for the event of interest and competing event
  tmpdat12_event <- tmpdat1 %>%
    filter(!!as.name(evtvar)!=0)
  
  nj12 <- data.frame(wtd.table(tmpdat12_event[,dayvar], weights=tmpdat12_event$wt))
  names(nj12) <- c("time", "w.sum.event")
  
  atrisk12 <- atrisk_all %>%
    arrange(desc(time))%>%
    mutate(w.cum.sum = cumsum(w.sum))%>%
    filter(time %in% nj12$time)%>%
    arrange(time)
  
  # check the times in two data sets match
  if(setequal(nj12$time, atrisk12$time)!=TRUE){
    stop("Time points do not match")
  }
  haz12 <- nj12$w.sum.event/atrisk12$w.cum.sum
  
  cbind(nj12, atrisk12, haz12) %>% head
  cbind(nj1, atrisk1, haz1) %>% head
  
  s12 = c(1,cumprod(1-haz12))
  tm12 = c(0,tm12)
  s1 <- s12[(which(tm12 %in% tm1)-1)]
  
  cif = cumsum(s1*haz1)
  out=cbind(tm1,cif)
  if(max(tm1)<6){ends=cbind(tm1=6, cif=max(cif)); out=cbind(out, ends)}
  return(out)
}

#Jian created this function by modifying Chong's code
#this function calculates the mean of cif calculated for multiple data sets
#requirements for the input data set imp.long. 1)it is a stack of multiple data sets generated by imputation. 
#each data set satisfies the requirements for the function get_cif_faster() above
#!!!!the event status and fllowup time SHOULD BE IDENTICAL among the data sets
#2)the should be a variabe .imp indicates the id of each data set
cumcif=function(imp.long,evtvar, dayvar, weightvar=NULL){
  cif1=NULL
  cif0=NULL
  m=max(imp.long$.imp)
  for (i in 1:m){
    dat = imp.long[imp.long$.imp==i, ]
    cif1 =cbind(cif1, getcif_faster(dat=dat,tx=1, evtvar=evtvar, dayvar =dayvar, weightvar=weightvar ))
    cif0= cbind(cif0, getcif_faster(dat=dat,tx=0, evtvar=evtvar, dayvar=dayvar, weightvar=weightvar))
  }
  mean.cif1= data.frame(Time=cif1[,1], cif=apply(cif1[, 2*(1:m)],1,mean))
  mean.cif0= data.frame(Time=cif0[,1], cif=apply(cif0[, 2*(1:m)],1,mean))
  
  cif.e=rbind(mean.cif0 %>% mutate(group="trt0"),mean.cif1 %>% mutate(group="trt1"))
  return(cif.e)
}
